/*
 * @(#)pres_writerHistoryDriver.h    generated by: makeheader    Mon Dec  3 23:08:15 2007
 *
 *		built from:	writerHistoryDriver.ifc
 */

#ifndef pres_writerHistoryDriver_h
#define pres_writerHistoryDriver_h


  #ifndef osapi_type_h
    #include "osapi/osapi_type.h"
  #endif
  #ifndef reda_fastBuffer_h
    #include "reda/reda_fastBuffer.h"
  #endif
  #ifndef mig_generator_h
    #include "mig/mig_generator.h"
  #endif
  #ifndef pres_dll_h
    #include "pres/pres_dll.h"
  #endif
  #ifndef pres_common_h
    #include "pres/pres_common.h"
  #endif
  #ifndef writer_history_interface_h
    #include "writer_history/writer_history_interface.h"
  #endif
#ifdef __cplusplus
    extern "C" {
#endif

struct PRESWriterHistoryDriverUnblockListener;

struct PRESWriterHistoryDriverUnblockListenerStorage {
    void *field[4];
};

struct REDAWorker;

typedef void (*PRESWriterHistoryDriverOnUnblockCallback)(
    const struct PRESWriterHistoryDriverUnblockListener *listener,
    const struct PRESWriterHistoryDriverUnblockListenerStorage *storage,
    struct REDAWorker *worker);

struct PRESWriterHistoryDriverUnblockListener {
    PRESWriterHistoryDriverOnUnblockCallback onUnblock;
};

struct PRESWriterHistoryDriver;

struct PRESWriterHistoryDriverProperty {
    /*e Control growth in number of entries. */
    struct REDAFastBufferPoolGrowthProperty entryCount;

    /*e The maximum allowable number of entries per instance. */
    int maximalEntryPerInstanceCount;

    /*e Number of instances to allocate initially. */
    struct REDAFastBufferPoolGrowthProperty instanceCount;

    /*e Control growth in number of concurrent (blocking) write. */
    struct REDAFastBufferPoolGrowthProperty outstandingWriteCount;

    /*e Denotes whether the disposal of an instance should also automatically
      unregister the instance.  This is generally used when it is known that 
      instances are only ever written by a single writer. */
    RTIBool autoUnregister;

    /*e Whether the owner/writer of the wh is publishing asynchronously. 
        Under best effort, asynchronous writer needs samples to remain in queue
        until fully sent. */
    RTIBool asynchronousPublishing;

    /*e The reliability QoS. */
    struct PRESReliabilityQosPolicy reliabilityQos;
    /*e The deadline QoS.
      A period set to RTI_NTP_TIME_MAX is interpreted as infinite.  In addition,
      the period may not exceed PRES_DEADLINE_QOS_POLICY_DEADLINE_PERIOD_MAX. */
    struct PRESDeadlineQosPolicy deadlineQos;
    /*e The history QoS. */
    struct PRESHistoryQosPolicy historyQos;
    /*e The durability QoS. */
    struct PRESDurabilityQosPolicy durabilityQos;
    /*e The lifespan QoS.  
      A lifespan duration set to RTI_NTP_TIME_MAX is interpreted as
      infinite. In addition, the duration may not exceed
      PRES_LIFESPAN_QOS_POLICY_LIFESPAN_DURATION_MAX. */
    struct PRESLifespanQosPolicy lifespanQos;
    /*e If there are not enough resource limits to satisfy the history depth
      when the history kind is KEEP_LAST but there are at least enough to
      satisfy a history depth of 1, thie value denotes whether to sacrifice
      reliability by dropping all but the last unacked sample of an instance
      if necessary in order to avoid blocking. */
    RTIBool sacrificeReliability;
    /*e Maximum size of the serialized user data.
    */
    int userDataBufferMaxSizeSerialized;
    /*e Maximum size of the serialized key data.
    */
    int keyDataBufferMaxSizeSerialized;
    /*e Specifies whether resources and logic is enabled for gathering statistics
    */
    RTIBool gatherStatistics;
};


  #define PRES_WRITER_HISTORY_DRIVER_PROPERTY_DEFAULT { \
    /* entryCount */                           \
    {32, REDA_FAST_BUFFER_POOL_UNLIMITED, REDA_FAST_BUFFER_POOL_UNLIMITED}, \
    -1,  /* maximalEntryPerInstanceCount: unlimited */\
    /* instanceCount */                        \
    {8, REDA_FAST_BUFFER_POOL_UNLIMITED, REDA_FAST_BUFFER_POOL_UNLIMITED}, \
    {1, 4, REDA_FAST_BUFFER_POOL_UNLIMITED}, /* outstandingWriteCount */ \
    RTI_FALSE, /* autoUnregister */                   \
    RTI_FALSE, /* asynchronousPublishing */ \
    {PRES_BEST_EFFORT_RELIABILITY_QOS},               \
    {RTI_NTP_TIME_MAX},                               \
    {PRES_KEEP_LAST_HISTORY_QOS,PRES_NONE_REFILTER_QOS,1},\
    {PRES_VOLATILE_DURABILITY_QOS},                   \
    {RTI_NTP_TIME_MAX},                               \
    RTI_TRUE,-1,-1,                  \
    RTI_FALSE /* gatherStatistics */ \
   }


  #define PRES_WRITER_HISTORY_DRIVER_ADD_FAILURE_INTERNAL (1)


  #define PRES_WRITER_HISTORY_DRIVER_ADD_FAILURE_RESOURCE_CONTENTION (2)


  #define PRES_WRITER_HISTORY_DRIVER_ADD_FAILURE_FULL (3)


  #define PRES_WRITER_HISTORY_DRIVER_ADD_FAILURE_OUT_OF_RESOURCES (4)


  #define PRES_WRITER_HISTORY_DRIVER_ADD_FAILURE_NO_INSTANCE (5)


  #define PRES_WRITER_HISTORY_DRIVER_ADD_FAILURE_TYPE_PLUGIN (6)


  #define PRES_WRITER_HISTORY_DRIVER_ADD_FAILURE_OUT_OF_ORDER (7)


  #define PRES_WRITER_HISTORY_DRIVER_ADD_FAILURE_LIFESPAN_EXPIRED (8)


  #define PRES_WRITER_HISTORY_DRIVER_GET_FAILURE_INTERNAL (1)


  #define PRES_WRITER_HISTORY_DRIVER_GET_FAILURE_NO_INSTANCE (2)

extern PRESDllExport void
PRESWriterHistoryDriver_refilter(
    struct PRESWriterHistoryDriver *me,
    int filterIndex,
    struct PRESContentFilterQosPolicy *policy);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_registerInstance(
    struct PRESWriterHistoryDriver *me, int *failReason, 
    struct PRESInstanceHandle *handle, const void *instance,
    const struct RTINtpTime *sourceTimestamp,
    const struct RTINtpTime *now, struct REDAWorker *worker);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_registerInstanceX(
    struct PRESWriterHistoryDriver *me, int *failReason, 
    struct PRESInstanceHandle *handle, const void *key,
    const struct RTINtpTime *sourceTimestamp,
    const struct RTINtpTime *now, struct REDAWorker *worker);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_unregisterInstance(
    struct PRESWriterHistoryDriver *me, int *failReason, 
    struct REDASequenceNumber *firstAvailableSn,
    struct MIGGeneratorSample **sample,
    const struct MIGRtpsGuid *readerGuid,     
    const void *instance,
    const struct PRESInstanceHandle *handle,
    const struct RTINtpTime *sourceTimestamp,
    const struct RTINtpTime *now,
    struct REDAWorker *worker);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_freeInstance(
    struct PRESWriterHistoryDriver *me, int *failReason,
    const void *instance,
    const struct PRESInstanceHandle *handle,
    struct REDAWorker *worker);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_getKey(
    struct PRESWriterHistoryDriver *me, int *failReason, void *instance,
    const struct PRESInstanceHandle *handle, struct REDAWorker *worker);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_getKeyX(
    struct PRESWriterHistoryDriver *me, int* failReason, void *key,
    const struct PRESInstanceHandle *handle, struct REDAWorker *worker);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_addWrite(
    struct PRESWriterHistoryDriver *me, int *failReason, 
    struct REDASequenceNumber *firstAvailableSn,
    struct MIGGeneratorSample **sample,
    MIGGeneratorEndian endian,
    const struct MIGRtpsGuid *readerGuid,     
    const struct PRESOriginalWriterInfo * originalWriterInfo,
    const void *data,
    const struct PRESInstanceHandle *handle, 
    const struct RTINtpTime *timestamp, const struct RTINtpTime *now, 
    struct COMMENDFilterStatus *filterStatus,
    struct REDAWorker *worker);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_addDispose(
    struct PRESWriterHistoryDriver *me, int *failReason, 
    struct REDASequenceNumber *firstAvailableSn,
    struct MIGGeneratorSample **sample,
    const struct MIGRtpsGuid *readerGuid, 
    const struct PRESOriginalWriterInfo * originalWriterInfo,
    const void *data,
    const struct PRESInstanceHandle *handle, 
    const struct RTINtpTime *timestamp, const struct RTINtpTime *now, 
    struct REDAWorker *worker);

extern PRESDllExport void
PRESWriterHistoryDriver_finish(
    struct PRESWriterHistoryDriver *me, struct MIGGeneratorSample *sample,
    const struct RTINtpTime *now, struct REDAWorker *worker);

extern PRESDllExport void
PRESWriterHistoryDriver_beginCoherentChanges(struct PRESWriterHistoryDriver *me);

extern PRESDllExport RTIBool
PRESWriterHistoryDriver_endCoherentChanges(
    struct PRESWriterHistoryDriver *me, int *failReason, 
    struct MIGGeneratorSample **sample);

extern PRESDllExport void 
PRESWriterHistoryDriver_beginInstanceIteration(struct PRESWriterHistoryDriver *me);

extern PRESDllExport void 
PRESWriterHistoryDriver_endInstanceIteration(struct PRESWriterHistoryDriver *me);

extern PRESDllExport struct PRESWriterHistoryDriverInstance *
PRESWriterHistoryDriver_getInstanceIteration(struct PRESWriterHistoryDriver *me);

extern PRESDllExport void 
PRESWriterHistoryDriver_getInstanceHandle(
    struct PRESWriterHistoryDriver *me, 
    struct PRESInstanceHandle *handle, 
    struct PRESWriterHistoryDriverInstance *instance);

extern PRESDllExport RTIBool PRESWriterHistoryDriver_checkDeadline(
    struct PRESWriterHistoryDriver *me, 
    int * deadlineMissedCount,
    struct PRESInstanceHandle * lastHandle,
    struct RTINtpTime * minNextDeadline,
    const struct RTINtpTime *now);

extern PRESDllExport RTIBool 
PRESWriterHistoryDriver_requestData(
    struct PRESWriterHistoryDriver *me,
    struct MIGGeneratorSample **sample, RTIBool *dataValid,
    struct REDASequenceNumber *firstRelevantSn, 
    struct REDASequenceNumber *nextRelevantSn,
    const struct REDASequenceNumber *requestSn,
    const struct RTINtpTime *now,
    int filterIndex,
    struct COMMENDFilterStatus *filterStatus,
    struct PRESContentFilterQosPolicy *policy,
    struct REDAWorker *worker);

extern PRESDllExport RTIBool 
PRESWriterHistoryDriver_completeBeAsynchPubBySample(
    struct PRESWriterHistoryDriver *me,
    struct MIGGeneratorSample *completedSample,
    const struct RTINtpTime *now, /* optional */
    struct REDAWorker *worker);

extern PRESDllExport RTIBool 
PRESWriterHistoryDriver_completeBeAsynchPub(
    struct PRESWriterHistoryDriver *me,
    const struct REDASequenceNumber *completedSn,
    const struct RTINtpTime *now,
    struct REDAWorker *worker);

extern PRESDllExport RTIBool 
PRESWriterHistoryDriver_completeBeAsynchPubAndPrior(
    struct PRESWriterHistoryDriver *me,
    const struct REDASequenceNumber *completedSn,
    const struct RTINtpTime *now, /* optional */
    struct REDAWorker *worker);

extern PRESDllExport RTIBool 
PRESWriterHistoryDriver_changeFirstUnackedSn(
    struct PRESWriterHistoryDriver *me,
    const struct REDASequenceNumber *firstUnackedSn, 
    const struct RTINtpTime *now,
    struct REDAWorker *worker);

extern PRESDllExport void 
PRESWriterHistoryDriver_setDeadlinePeriod(
    struct PRESWriterHistoryDriver *me, 
    const struct RTINtpTime *deadlinePeriod);

extern PRESDllExport void
PRESWriterHistoryDriver_lookupInstance(struct PRESWriterHistoryDriver *me,
                                   const void* key_holder,
                                   struct PRESInstanceHandle *handle);

extern PRESDllExport void
PRESWriterHistoryDriver_lookupInstanceX(struct PRESWriterHistoryDriver *me,
                                   const void* key_holder,
                                   struct PRESInstanceHandle *handle);

extern PRESDllExport RTIBool 
PRESWriterHistoryDriver_pruneLifespanExpiredEntries(
    struct PRESWriterHistoryDriver *me, 
    const struct RTINtpTime *now,
    RTIBool singleEntry);

extern PRESDllExport void 
PRESWriterHistoryDriver_setLifespan(
    struct PRESWriterHistoryDriver *me, 
    const struct PRESLifespanQosPolicy *lifespanQos,
    const struct RTINtpTime *now);

extern PRESDllExport int 
PRESWriterHistoryDriver_getNonReclaimableCount(struct PRESWriterHistoryDriver *me);

extern PRESDllExport void
PRESWriterHistoryDriver_getHighestReclaimableSn(struct PRESWriterHistoryDriver *me,
                                                struct REDASequenceNumber * sn);

extern void PRESWriterHistoryDriver_enable(struct PRESWriterHistoryDriver * me,
                                      const struct RTINtpTime* nowIn);


extern	void PRESWriterHistoryDriver_getFirstSnInCoherentSet(
        struct PRESWriterHistoryDriver* me,
        struct REDASequenceNumber * sn); 
struct PRESTypePluginData;

extern PRESDllExport struct PRESWriterHistoryDriver *
PRESWriterHistoryDriver_new(
    struct REDASequenceNumber * firstSn,
    struct REDASequenceNumber * lastSn,
    struct REDASequenceNumber * lowestUnackSn,
    const struct PRESWriterHistoryDriverProperty *property,
    const struct MIGRtpsGuid *guid,
    const struct PRESSequenceProperty * dpProperties,
    const struct PRESSequenceProperty * dwProperties,
    const struct PRESTypePlugin *typePlugin,
    const char * whPluginName,
    struct NDDS_WriterHistory_Plugin * whPlugin,
    void *serializeOption,
    struct RTIClock *clock);

extern PRESDllExport void
PRESWriterHistoryDriver_delete(struct PRESWriterHistoryDriver *me);

 
extern	RTIBool PRESWriterHistoryDriver_getStatistics(
        struct PRESWriterHistoryDriver* me,
        struct NDDS_WriterHistory_Statistics *stats);

 
extern	RTIBool PRESWriterHistoryDriver_resetStatistics(
        struct PRESWriterHistoryDriver* me);


#ifdef __cplusplus
    }	/* extern "C" */
#endif

#endif /* pres_writerHistoryDriver_h */
